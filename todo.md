## 一、目前已完成/未完成

### ✅ 已完成

- 四人升级游戏完整 **前半流程**
- 定主 / 改主 / 攻主 / 扣底
- 先手出牌 + 甩牌裁剪（核心难点）
- 状态机 + UI + 规则引擎基本成型

### ❌ 尚未完成（但已具备承载能力）

- 跟牌（FollowMove 合法性）
- 回合胜负判定
- 回合得分（吃分）
- 末墩抠底
- 小局结算 / 升级
- 整局结束判定

## 二、基础体验与启动流程（低风险 / 立即可做）

### 2.1 前端显示与身份约定

- seat 显示：`seat0123 → ABCD`
- `uid` 允许前端自行设置（可有默认）
- 去掉 **手动开局**
- 增加 **开局信息广播**

👉 这一组是 **纯 UX / 协议层改动**，不会影响规则逻辑，适合当“热身改动”。

---

## 三、连接 / 会话 / 断线重连（中风险，需提前规划）

### 3.1 当前问题（你已经精准识别）

- 重连 = 同 uid 再次 Join
- 现逻辑：
    - 若 uid 已坐下 → `Online=true`
    - 但 `conns` 是连接对象集合 → 会多一个连接

### 3.2 阶段性处理策略（合理）

- **阶段 1（现在）**

  ✔ 不处理 “同 uid 踢旧连接”

  ✔ 只保证状态正确（Online / Seat 不乱）

- **阶段 2（优化）**
    - 引入 `uid -> conn` 映射
    - Join 时：
        - 替换旧 conn
        - 或显式关闭旧连接

👉 你现在的判断是对的：**先别引入踢连接逻辑，否则和 WS 并发 / ACK 一起复杂度爆炸**。

---

## 四、状态建模与核心数据结构（高风险 / 省返工关键）

> 这是你 todo 里 技术含量最高、也是最值得提前做对的部分
>

### 4.1 GameState 传递方式

- 想法：`GameState` 或放入 `ctx`
- 核心坑（你已点名）：

> ❌ 失败路径会污染状态（最致命）
>

**建议结论（明确）：**

- ❌ 不要在 reducer 里“就地改 state + 可能失败”
- ✅ 正确做法：
    - reducer 内部：
        - `next := state.Clone()`
        - 在 `next` 上修改
        - 成功 → 提交
        - 失败 → 丢弃

> 这是升级游戏这种“规则复杂系统”的生死线
>

---

### 4.2 TrickState 结构升级（★★★★★）

### 当前

```go
Lead + Follows[3]

```

### 建议

```go
Plays [4]*PlayedMove// 按 seat index

```

好处：

- 不再区分 lead / follow 的特殊路径
- 结算逻辑天然遍历
- 断线重连 / snapshot 更干净
- 与“Seat=-1 未出牌”彻底解耦

👉 **这是你整个出牌系统最重要的一次结构升级**

---

### 4.3 未出牌表示方式

- 现：`Seat = -1`
- 建议：`PlayedMove == nil`

**原因：**

- snapshot 不需要初始化
- 判断逻辑更 Go 风格
- 避免 magic number

---

### 4.4 Move / Block 结构收敛

### 当前问题

- `Blocks [][]Block` 层级语义不清晰

### 建议模型

```go
type BlockGroupstruct {
    Type       BlockType
    SuitClass  SuitClass
    TractorLenint
    Blocks     []Block
}

type Movestruct {
    Groups []BlockGroup
    ...
}

```

👉 这是在为 **甩牌 / 跟牌 / 可比性判断** 提前铺路。

---

## 五、事件系统、幂等性与错误体系（中高风险）

### 5.1 WS 幂等性 & 顺序问题

你当前：

- room 内 reducer 单线程 ✔

但未来风险：

- 前端连点
- 网络抖动
- 重连重发

### 强烈建议（你写得已经非常专业）：

- client event：
    - `clientSeq` 或 `reqId`
- server response：
    - `ackReqId`

👉 **这是防 UI 乱序的“唯一正解”**

---

### 5.2 错误码标准化（★★★★★）

### 当前问题

- 中文字符串 + fmt
- 前端不可判断

### 建议

```go
type AppErrorstruct {
    Codestring
    Msgstring
}

```

示例：

- `ERR_NOT_YOUR_TURN`
- `ERR_LEAD_ALREADY_PLAYED`
- `ERR_MIXED_SUITCLASS`
- `ERR_CARD_NOT_IN_HAND`

👉 后续你做 **规则细分 / 本地化提示 / 测试断言** 都会感谢现在的你。

---

### 5.3 Phase 的“唯一入口 / 出口”约束

建议你 **显式文档化**：

> 每个 phase：
>
- 允许哪些事件
- 成功后进入哪些 phase
- 失败是否回滚

这一步不是为了文档，是为了 **防止 reducer 里出现“偷偷改状态”**。

---

## 六、选择集（SelectedCards）生命周期（易踩坑点）

### 当前

- phase 切换 → 清空（已实现）

### 建议升级为 **事件驱动清空**

- ✅ 出牌成功（snapshot 中 plays 更新）
- ✅ trump 变化 → 手牌重排
- ✅ 扣底成功
- ❌ 出牌失败不清空（你已处理，保持）

👉 这是前端体验与状态一致性的关键。

---

## 七、规则核心：出牌 / 跟牌 / 结算

### 7.1 跟牌（明确你当前阶段的目标）

- **只判断合法性**
- 不分析牌型大小
- 原则：
    - 能跟同花色 / 同牌域 → 必须跟
    - `SuitClass` 增加 `Mix` 类型

这是非常正确的 **阶段切分**。

---

### 7.2 结算（Trick Winner 判定）

逻辑顺序（你描述得已经很严谨）：

1. 判断每个玩家出牌是否 **可比**
2. 优先级：
    - 主杀 > 副牌
    - 与先手牌域一致
    - 牌型一致
3. 有主杀 → 副牌全部失效

👉 这里 **TrickState = Plays[4]** 会让代码简单 50%。

---

## 八、阶段化实现路线（你已给出，我帮你整理）

### 第 1 阶段：最简可跑通

- 固定硬主
- 不含定主 / 改主
- 只保证：
    - 轮流出牌
    - 数量一致
    - 手牌出完结束

### 后续补齐

- 甩牌失败判定
- 分牌与吃分（只记打家）
- 抠底翻倍
- 小局结算 → 升级 → 下一局先手

---

## 九、工程质量（长期收益）

- table-driven 单测（规则引擎必须）
- replay log（回放 / debug / 对拍）

---

## 十、你“最值得立刻做的 5 件事”（我确认：完全正确）

按 **省返工程度排序**：

1. **TrickState → `Plays[4]`**
2. **SuitClass 来源统一（算 or 缓存，但只能选一个）**
3. **错误码标准化**
4. **snapshot 中未出牌字段用 nil**
5. **核心规则函数的 table-driven 单测 + replay log**

> 这 5 件事，任何一件拖到后面，都会在“跟牌 / 结算 / 重连”阶段放大 3 倍成本。
>